<html>
  <head>
    <link rel="stylesheet" href="style.css">
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://unpkg.com/@c-frame/aframe-physics-system@4.2.3/dist/aframe-physics-system.min.js"></script>
  </head>
  <body>
    <a href="../" class="back-button">Back to Home</a>
    <div class="game-ui">
      <h3>Network Game</h3>
      <p><strong>Connections:</strong> <span id="connection-count">0</span></p>
      <p><strong>Nodes:</strong> <span id="node-count">0</span></p>
      <p><strong>Click objects</strong> to transform and activate physics!</p>
      <p><strong>Objects will fall and bounce!</strong></p>
    </div>
    <a-scene
      physics="enabled: true; debug: false; maxSubSteps: 1; fixedTimeStep: 1/60"
      renderer="antialias: true; colorManagement: true; sortObjects: true">
      <!-- Initial objects scattered in space -->
      <a-box id="obj-1" position="-2 1 -3" rotation="0 45 0" color="#4CC3D9" class="clickable network-node"></a-box>
      <a-sphere id="obj-2" position="2 1.5 -4" radius="0.5" color="#EF2D5E" class="clickable network-node"></a-sphere>
      <a-cylinder id="obj-3" position="0 2 -5" radius="0.4" height="1" color="#FFC65D" class="clickable network-node"></a-cylinder>
      <a-box id="obj-4" position="-1.5 0.5 -2" rotation="30 0 45" color="#7BC8A4" class="clickable network-node"></a-box>
      <a-sphere id="obj-5" position="1.5 0.8 -3.5" radius="0.5" color="#9B59B6" class="clickable network-node"></a-sphere>
      <a-cylinder id="obj-6" position="-2.5 1.2 -4.5" radius="0.4" height="1" color="#E74C3C" class="clickable network-node"></a-cylinder>
      <a-box id="obj-7" position="2.2 0.3 -2.5" rotation="0 60 0" color="#3498DB" class="clickable network-node"></a-box>
      <a-sphere id="obj-8" position="0 1.8 -6" radius="0.5" color="#F39C12" class="clickable network-node"></a-sphere>

      <!-- Ground plane with physics -->
      <a-plane
        position="0 0 -4"
        rotation="-90 0 0"
        width="10"
        height="10"
        color="#2c3e50"
        opacity="0.3"
        static-body
        shape="box">
      </a-plane>
      <a-sky color="#1a1a2e"></a-sky>

      <!-- Lighting - optimized for performance -->
      <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
      <a-light type="directional" position="5 10 5" intensity="0.7" cast-shadow="false"></a-light>

      <!-- Camera -->
      <a-camera id="main-camera" position="0 2 5" look-controls wasd-controls="enabled: true"></a-camera>
    </a-scene>

    <script>
      // Define object types to cycle through
      const objectTypes = [
        { type: 'box', tag: 'a-box', props: 'width="1" height="1" depth="1"' },
        { type: 'sphere', tag: 'a-sphere', props: 'radius="0.5"' },
        { type: 'cylinder', tag: 'a-cylinder', props: 'radius="0.5" height="1"' },
        { type: 'torus', tag: 'a-torus', props: 'radius="0.5" radius-tubular="0.1"' },
        { type: 'octahedron', tag: 'a-octahedron', props: 'radius="0.5"' },
        { type: 'tetrahedron', tag: 'a-tetrahedron', props: 'radius="0.5"' },
        { type: 'cone', tag: 'a-cone', props: 'radius-bottom="0.5" radius-top="0.1" height="1"' },
        { type: 'dodecahedron', tag: 'a-dodecahedron', props: 'radius="0.5"' }
      ];

      // Colors to cycle through
      const colors = ['#4CC3D9', '#EF2D5E', '#FFC65D', '#7BC8A4', '#9B59B6', '#E74C3C', '#3498DB', '#F39C12'];

      // Network tracking
      const network = {
        nodes: new Map(), // id -> {element, position, connections: Set}
        connections: new Set(), // Set of connection IDs like "id1-id2"
        connectionDistance: 3.5 // Maximum distance for connections
      };

      // Update UI
      function updateUI() {
        document.getElementById('connection-count').textContent = network.connections.size;
        document.getElementById('node-count').textContent = network.nodes.size;
      }

      // Calculate distance between two positions
      function getDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        const dz = pos1.z - pos2.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
      }

      // Create connection line between two objects
      function createConnection(id1, id2, pos1, pos2) {
        return;

        const connectionId = [id1, id2].sort().join('-');

        // Check if connection already exists
        if (network.connections.has(connectionId)) {
          return;
        }

        network.connections.add(connectionId);

        // Calculate distance and direction
        const distance = getDistance(pos1, pos2);
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dz = pos2.z - pos1.z;

        // Calculate midpoint
        const midX = (pos1.x + pos2.x) / 2;
        const midY = (pos1.y + pos2.y) / 2;
        const midZ = (pos1.z + pos2.z) / 2;

        // Create line entity using a-cylinder
        const lineId = 'line-' + connectionId;
        const line = document.createElement('a-cylinder');
        line.setAttribute('id', lineId);
        line.setAttribute('radius', '0.03');
        line.setAttribute('height', distance);
        line.setAttribute('color', '#00ff88');
        line.setAttribute('opacity', '0.6');
        line.setAttribute('position', midX + ' ' + midY + ' ' + midZ);

        // Calculate rotation to align cylinder from pos1 to pos2
        // First, find the angle in the XZ plane (yaw)
        const yaw = Math.atan2(dx, dz) * 180 / Math.PI;
        // Then, find the pitch angle (elevation)
        const pitch = Math.atan2(-dy, Math.sqrt(dx*dx + dz*dz)) * 180 / Math.PI;

        line.setAttribute('rotation', pitch + ' ' + yaw + ' 0');
        line.setAttribute('class', 'network-line');

        document.querySelector('a-scene').appendChild(line);
        updateUI();
      }

      // Update connections for a node (throttled for performance)
      let connectionUpdateTimeout = null;
      function updateConnections(nodeId, position) {
        // Throttle connection updates to avoid performance issues
        if (connectionUpdateTimeout) {
          clearTimeout(connectionUpdateTimeout);
        }
        connectionUpdateTimeout = setTimeout(function() {
          network.nodes.forEach((node, otherId) => {
            if (otherId !== nodeId && node.position) {
              const distance = getDistance(position, node.position);
              if (distance <= network.connectionDistance) {
                //createConnection(nodeId, otherId, position, node.position);
              }
            }
          });
        }, 100); // Only update connections every 100ms
      }

      // Register a node in the network
      function registerNode(element) {
        const id = element.getAttribute('id');
        const pos = element.getAttribute('position');
        const position = typeof pos === 'object' ? pos : {x: 0, y: 0, z: 0};

        if (!network.nodes.has(id)) {
          network.nodes.set(id, {
            element: element,
            position: position,
            connections: new Set()
          });
        } else {
          // Update position
          network.nodes.get(id).position = position;
          network.nodes.get(id).element = element;
        }

        // Update connections
        updateConnections(id, position);
        updateUI();
      }

      function transformObject(element) {
        // Get current object type
        const currentTag = element.tagName.toLowerCase();
        let currentType = objectTypes.findIndex(obj => obj.tag === currentTag);

        // If current type not found in cycle list, start from beginning
        if (currentType === -1) {
          currentType = objectTypes.length - 1; // Will cycle to 0 on next line
        }

        // Get next object type (cycle through and loop back to start)
        const nextIndex = (currentType + 1) % objectTypes.length;
        const nextObject = objectTypes[nextIndex];

        // Get current attributes
        const position = element.getAttribute('position');
        const rotation = element.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
        const color = colors[Math.floor(Math.random() * colors.length)];
        const id = element.getAttribute('id') || 'obj-' + Date.now();

        // Preserve scale if it exists
        const scale = element.getAttribute('scale') || { x: 1, y: 1, z: 1 };

        // Create new element
        const newElement = document.createElement(nextObject.tag);
        newElement.setAttribute('id', id);
        newElement.setAttribute('position', position);
        newElement.setAttribute('rotation', rotation);
        newElement.setAttribute('scale', scale);
        newElement.setAttribute('color', color);
        newElement.setAttribute('class', 'clickable');

        // Set specific properties based on object type
        if (nextObject.tag === 'a-box') {
          newElement.setAttribute('width', '1');
          newElement.setAttribute('height', '1');
          newElement.setAttribute('depth', '1');
        } else if (nextObject.tag === 'a-sphere') {
          newElement.setAttribute('radius', '0.5');
        } else if (nextObject.tag === 'a-cylinder') {
          newElement.setAttribute('radius', '0.5');
          newElement.setAttribute('height', '1');
        } else if (nextObject.tag === 'a-torus') {
          newElement.setAttribute('radius', '0.5');
          newElement.setAttribute('radius-tubular', '0.1');
        } else if (nextObject.tag === 'a-octahedron' || nextObject.tag === 'a-tetrahedron' || nextObject.tag === 'a-dodecahedron') {
          newElement.setAttribute('radius', '0.5');
        } else if (nextObject.tag === 'a-cone') {
          newElement.setAttribute('radius-bottom', '0.5');
          newElement.setAttribute('radius-top', '0.1');
          newElement.setAttribute('height', '1');
        }

        // Add animation for smooth transition (simplified for performance)
        newElement.setAttribute('animation__scale', {
          property: 'scale',
          from: '0.5 0.5 0.5',
          to: '1 1 1',
          dur: 200,
          easing: 'easeOutQuad'
        });

        // Replace the element
        element.parentNode.replaceChild(newElement, element);

        // Enable physics on the new object - make it dynamic so it falls and bounces
        // Wait for element to be attached to scene
        setTimeout(function() {
          // Set physics body based on object type
          let shape = 'box';
          if (nextObject.tag === 'a-sphere') {
            shape = 'sphere';
          } else if (nextObject.tag === 'a-cylinder' || nextObject.tag === 'a-cone') {
            shape = 'cylinder';
          } else if (nextObject.tag === 'a-torus') {
            shape = 'hull';
          } else {
            shape = 'box';
          }

          // Enable physics with bounce - optimized settings
          const physicsConfig = {
            shape: shape,
            mass: 1,
            restitution: 0.6, // Reduced bounciness for better performance
            friction: 0.4,
            linearDamping: 0.2, // Increased damping to reduce calculations
            angularDamping: 0.2,
            type: 'dynamic',
            // Performance optimizations
            emitCollisionEvents: false // Disable collision events for better performance
          };
          newElement.setAttribute('dynamic-body', physicsConfig);

          // Give it a small random velocity to make it more interesting
          // Use requestAnimationFrame for better timing
          requestAnimationFrame(function() {
            setTimeout(function() {
              const body = newElement.body;
              if (body && body.velocity) {
                const randomX = (Math.random() - 0.5) * 0.3;
                const randomZ = (Math.random() - 0.5) * 0.3;
                body.velocity.set(randomX, 0, randomZ);
              }
            }, 100);
          });
        }, 50);

        // Register in network (skip connection updates for performance)
        // registerNode(newElement); // Disabled to improve physics performance

        // Add click listener to new element
        newElement.addEventListener('click', function() {
          transformObject(this);
        });
      }

      // Initialize network with existing nodes (disabled for performance)
      function initializeNetwork() {
        // Disabled to improve physics performance
        // document.querySelectorAll('.network-node').forEach(function(element) {
        //   registerNode(element);
        // });
      }

      // Mouse click handler with raycasting
      document.querySelector('a-scene').addEventListener('loaded', function() {
        const sceneEl = document.querySelector('a-scene');
        const cameraEl = document.querySelector('#main-camera') || document.querySelector('a-camera');

        // Get Three.js - A-Frame bundles THREE.js
        // THREE should be available globally or through AFRAME
        const THREE = window.THREE || (typeof AFRAME !== 'undefined' && AFRAME.THREE ? AFRAME.THREE : null);

        if (!THREE) {
          console.error('Could not find THREE.js');
          return;
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Add click event listener to the canvas
        const canvas = sceneEl.canvas;

        canvas.addEventListener('click', function(event) {
          // Calculate mouse position in normalized device coordinates (-1 to +1)
          const rect = canvas.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          // Get camera object
          const camera = cameraEl.getObject3D('camera');

          // Update raycaster with camera and mouse position
          raycaster.setFromCamera(mouse, camera);

          // Get all clickable objects
          const clickableObjects = [];
          document.querySelectorAll('.clickable').forEach(function(element) {
            if (element.object3D && element.object3D.visible) {
              element.object3D.traverse(function(child) {
                if (child.isMesh) {
                  clickableObjects.push(child);
                }
              });
            }
          });

          // Check for intersections
          const intersects = raycaster.intersectObjects(clickableObjects, true);

          if (intersects.length > 0) {
            // Find the A-Frame entity that contains this mesh
            const clickedMesh = intersects[0].object;
            let aframeEntity = null;

            // Search through all clickable entities to find which one contains this mesh
            document.querySelectorAll('.clickable').forEach(function(el) {
              if (el.object3D && !aframeEntity) {
                el.object3D.traverse(function(child) {
                  if (child === clickedMesh && !aframeEntity) {
                    aframeEntity = el;
                  }
                });
              }
            });

            if (aframeEntity) {
              transformObject(aframeEntity);
            }
          }
        });

        // Initialize network
        initializeNetwork();
      });
    </script>
  </body>
</html>

